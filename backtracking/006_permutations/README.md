# Permutations

- ðŸ§© Problem link: [Leetcode](https://leetcode.com/problems/permutations/)
- ðŸš¦ Difficulty: ðŸŸ¡ Medium

## Concept

We can take a **permutation** of a set of elements by creating an ordered arrangement of those elements.

For example, a permutation from the set `{1,2,3}` could be
`{1,2,3}` or `{1,3,2}` or `{2,1,3}`.

Notice that the order of the elements is important in permutations. Unlike with combinations, we want to use all of the elements from the given set.

> Q: Given a distinct list of integers, return all possible distinct permutations of them.

The image below demonstrates how we can generate permutations for all numbers where the list given is `[1,2,3,4]`. We are given four elements, thus each permutation will be of size `4`.

- For the first element, we can choose any of the **four** elements.
- For the second element, we can choose any of the **three** remaining elements.
- For the third element, we can choose any of the **two** remaining elements.
- Finally, for the last element, we can choose the **single** remaining element.

![img](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e7247320-b76e-43f8-2a20-b10e7e769f00/sharpen=1)

The total number of permutations we can generate is `4âˆ—3âˆ—2âˆ—1=4!=24`. In general, the number of permutations we can generate is `n!` where `n` is the number of elements in the list.

### Iterative Solution

In the iterative solution, instead of performing the recursive call, we will just loop through `nums`, `for n in nums`. Toward the end of each `perms` loop, we can update our `perms` to be `nextPerms` so that we are not creating the same copy at each iteration.

```cpp
// Time: O(n^2 * n!)
vector<vector<int>> permutationsIterative(vector<int>& nums) {
    vector<vector<int>> perms = {{}};

    for (int n : nums) {
        vector<vector<int>> nextPerms;
        for (vector<int> p : perms) {
            for (int i = 0; i < p.size() + 1; i++) {
                vector<int> pCopy(p);
                pCopy.insert(pCopy.begin() + i, n);
                nextPerms.push_back(pCopy);
            }
        }
        perms = nextPerms;
    }
    return perms;
}
```

> A visualization of how we build up the iterative solution. The different colors are used to denote that at each iteration, we have a new copy of `p` and that we are not using the same copy throughout.

![img](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/25f55629-12b9-4743-575d-bc5bee0b0300/sharpen=1)

## ðŸ’¡ Approach

Let's think of how the problem can be broken down into subproblems.

1. We want all permutations of `{1,2,3}`.
2. We can generate permutations without including the `1`. This would be `{2,3}` and `{3,2}`.
3. To include `1` we can then insert `1` at each index of `{2,3}` and `{3,2}`.
4. The resulting permutations would be `{1,2,3}`, `{2,1,3}`, `{2,3,1}` and `{1,3,2}`, `{3,1,2}`, `{3,2,1}`.

The above approach can be applied recursively.

1. We first recursively call the `helper` function to generate all permutations without including the element at index `i`.
2. We then use nested loops to insert the element at index `i` in to each position in each permutation that was generated.

```cpp
#include <vector>

using std::vector;

// Time: O(n^2 * n!)
vector<vector<int>> permutationsRecursive(vector<int>& nums) {
    return helper(0, nums);
}

vector<vector<int>> helper(int i, vector<int>& nums) {
    if (i == nums.size()) {
        return {{}};
    }
    vector<vector<int>> resPerms;
    vector<vector<int>> perms = helper(i + 1, nums);
    for (vector<int> p : perms) {
        for (int j = 0; j < p.size() + 1; j++) {
            vector<int> pCopy(p);
            pCopy.insert(pCopy.begin() + j, nums[i]);
            resPerms.push_back(pCopy);
        }
    }
    return resPerms;
}
```

![img](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/43bbd153-07dd-4ccf-a588-1934c6fdf400/sharpen=1)

## ðŸ•’ Time and Space Complexity

- Time: O(n^2\*n!)
- Space: O(n!)

## âœ… Solution

```cpp
class Solution
{
public:
    vector<vector<int>> permute(vector<int> &nums) { return dfs(0, nums); }

private:
    vector<vector<int>> dfs(int i, vector<int> &nums)
    {
        if (i == nums.size())
            return {{}};

        vector<vector<int>> resPerms;

        // Recursively generate all permutations of the remaining elements (from
        // index i+1 onward)
        vector<vector<int>> perms = dfs(i + 1, nums);

        // For each smaller permutation generated by recursion
        for (auto p : perms)
        {
            for (int j = 0; j < p.size() + 1; j++)
            {
                vector<int> pCopy(p);
                pCopy.insert(pCopy.begin() + j,
                             nums[i]); // insert nums[i] at position j
                resPerms.push_back(pCopy);
            }
        }

        return resPerms;
    }
};
```
